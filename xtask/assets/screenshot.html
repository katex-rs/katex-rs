<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>katex-rs screenshot test</title>
  <!-- Stylesheet resolved by the xtask static server to KaTeX/dist/katex.min.css. -->
  <link rel="stylesheet" href="./katex.min.css" />
  <style>
    /* Match KaTeX screenshotter page metrics */
    body { font-family: "DejaVu Serif", serif; }
    #pre, #math, #post { font-size: 4em; line-height: 1.2; }
  </style>
  <style>
    /* Fonts from KaTeX test assets (no binary copy needed) */
    @font-face {
      font-family: "Batang";
      src: url("../../KaTeX/test/screenshotter/fonts/batang/batang.ttf") format("truetype");
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "Mincho";
      src: url("../../KaTeX/test/screenshotter/fonts/mincho/font_1_honokamin.ttf") format("truetype");
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }
    /* CJK/Hangul fallback families to match KaTeX screenshotter behavior */
    .katex .cjk_fallback { font-family: "Mincho", serif; }
    .katex .hangul_fallback { font-family: "Batang", serif; }
  </style>
</head>
<body>
  <span id="pre"></span>
  <span id="math"></span>
  <span id="post"></span>

  <script type="module">
    // ESM init: load WASM and shim, then render based on URL query.
    import initWasm, * as wasm from "./pkg/katex.js";

    const searchParams = new URLSearchParams(window.location.search || "");
    const implMode = (searchParams.get("impl") || "wasm").toLowerCase();

    function setStatus(state, message, stack) {
      const detail = { state, message: message || null };
      if (stack) {
        detail.stack = stack;
      } else if (Object.prototype.hasOwnProperty.call(detail, "stack")) {
        delete detail.stack;
      }
      window.__status = detail;
      try {
        window.dispatchEvent(new CustomEvent("katex-status", { detail }));
      } catch (_) {
        // ignore event dispatch failures (e.g., CustomEvent unavailable)
      }
      return detail;
    }

    window.__status = setStatus("init", null);

    function decodePayloadFromSearch(searchParams) {
      const entries = Array.from(searchParams.entries());
      if (entries.length === 0) {
        return { payload: { tex: "" } };
      }

      const payloadParam = searchParams.get("payload");
      if (payloadParam != null) {
        try {
          const parsed = JSON.parse(payloadParam);
          if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
            return { error: "payload parameter must be a JSON object" };
          }
          if (!Object.prototype.hasOwnProperty.call(parsed, "tex")) {
            parsed.tex = "";
          }
          return { payload: parsed };
        } catch (err) {
          const message = err && err.message ? err.message : String(err);
          return { error: `Failed to parse payload JSON: ${message}` };
        }
      }

      const payload = {};
      const macros = {};
      let hasMacros = false;
      for (const [key, value] of entries) {
        if (key === "payload") continue;
        if (key === "macro") {
          const idx = value.indexOf("=");
          if (idx >= 0) {
            const macroName = value.slice(0, idx);
            const expansion = value.slice(idx + 1);
            if (macroName) {
              macros[macroName] = expansion;
              hasMacros = true;
            }
          }
          continue;
        }
        if (key.startsWith("\\")) {
          macros[key] = value;
          hasMacros = true;
          continue;
        }
        payload[key] = value;
      }

      if (hasMacros) {
        payload.macros = macros;
      }
      if (!Object.prototype.hasOwnProperty.call(payload, "tex")) {
        payload.tex = "";
      }

      return { payload };
    }

    async function waitForImagesIn(el) {
      const imgs = Array.from(el.querySelectorAll("img"));
      await Promise.all(imgs.map(img => {
        if (img.complete && img.naturalWidth > 0) return Promise.resolve();
        return new Promise(resolve => {
          img.addEventListener("load", resolve, { once: true });
          img.addEventListener("error", resolve, { once: true });
        });
      }));
    }

    function setHTMLSafe(node, html) {
      node.textContent = "";
      if (typeof html !== "string" || html.length === 0) return;
      // Simple sanitizer: only allow <br> tags, everything else is text.
      const chunks = html.split(/(<br>)/i);
      for (const chunk of chunks) {
        if (chunk.toLowerCase() === "<br>") {
          node.appendChild(document.createElement("br"));
        } else if (chunk.length > 0) {
          node.appendChild(document.createTextNode(chunk));
        }
      }
    }

    async function ensureFonts() {
      if (!(document.fonts && document.fonts.load)) return;
      const promises = [];
      const loadFont = (name, style) => document.fonts.load((style || "") + " 10px " + name);
      // Mirror KaTeX screenshotter: bitmask indicates normal/bold/italic/bold italic
      const fonts = { AMS:1, Caligraphic:3, Fraktur:3, Main:15, Math:12, Script:1,
                      SansSerif:7, Size1:1, Size2:1, Size3:1, Size4:1, Typewriter:1 };
      for (const f in fonts) {
        const ff = fonts[f];
        const name = "KaTeX_" + f;
        if (ff & 1) promises.push(loadFont(name));
        if (ff & 2) promises.push(loadFont(name, "bold"));
        if (ff & 4) promises.push(loadFont(name, "italic"));
        if (ff & 8) promises.push(loadFont(name, "bold italic"));
      }
      promises.push(loadFont("Mincho"));
      promises.push(loadFont("Batang"));
      try { await Promise.all(promises); } catch (_) {}
    }

    const defaultImpl = implMode === "js" ? "js" : "wasm";
    window.__defaultImpl = defaultImpl;
    window.__currentImpl = null;

    let wasmInitPromise = null;
    let wasmApi = null;
    async function ensureWasmImplementation() {
      if (!wasmInitPromise) {
        wasmInitPromise = initWasm().then(() => {
          const api = {
            render: wasm.render,
            renderToString: wasm.renderToString,
            renderToHTML: wasm.renderToHTML,
            renderToMathML: wasm.renderToMathML,
            ParseError: wasm.ParseError,
          };
          if (typeof wasm.version === "function") {
            try {
              api.version = wasm.version();
            } catch (_) {
              // ignore version retrieval failures; keep API functional
            }
          }
          wasmApi = api;
        });
      }
      await wasmInitPromise;
      if (!wasmApi) {
        throw new Error("Failed to initialize KaTeX WASM implementation");
      }
      window.katex = wasmApi;
      return "wasm";
    }

    let jsModulePromise = null;
    async function ensureJsImplementation() {
      if (!jsModulePromise) {
        jsModulePromise = import("/katex.mjs");
      }
      const module = await jsModulePromise;
      window.katex = module;
      return "js";
    }

    async function loadImplementation(mode) {
      const target = typeof mode === "string" && mode.toLowerCase() === "js" ? "js" : "wasm";
      if (window.__currentImpl === target && window.katex) {
        return target;
      }
      const loaded = target === "js"
        ? await ensureJsImplementation()
        : await ensureWasmImplementation();
      window.__currentImpl = loaded;
      return loaded;
    }

    window.loadImplementation = loadImplementation;

    function normalizePayload(payload) {
      return payload && typeof payload === "object" && !Array.isArray(payload) ? payload : {};
    }

    async function renderInternal(payload, implPreference) {
      const mathNode = document.getElementById("math");
      const preNode = document.getElementById("pre");
      const postNode = document.getElementById("post");

      mathNode.innerHTML = "";
      const payloadObject = normalizePayload(payload);
      const pre = payloadObject.pre;
      const post = payloadObject.post;
      setHTMLSafe(preNode, pre && typeof pre === "string" ? pre : "");
      setHTMLSafe(postNode, post && typeof post === "string" ? post : "");

      const styles = payloadObject.styles;
      if (typeof styles === "string" && styles.length > 0) {
        mathNode.setAttribute("style", styles);
      } else {
        mathNode.removeAttribute("style");
      }

      const o = payloadObject;
      const opts = {};
      if ("displayMode" in o) opts.displayMode = !!o.displayMode;
      else if ("display" in o) opts.displayMode = !!o.display;

      if ("throwOnError" in o) opts.throwOnError = !!o.throwOnError;
      else if ("noThrow" in o) {
        const noThrow = typeof o.noThrow === "string"
          ? o.noThrow.toLowerCase() === "true"
          : !!o.noThrow;
        opts.throwOnError = !noThrow;
      }

      if (o.errorColor) opts.errorColor = String(o.errorColor);
      if (o.color) opts.color = String(o.color);

      ["leqno","fleqn","colorIsTextColor","globalGroup"].forEach(k => {
        if (k in o) opts[k] = !!o[k];
      });
      if ("minRuleThickness" in o) opts.minRuleThickness = Number(o.minRuleThickness);
      if ("maxExpand" in o) opts.maxExpand = Number(o.maxExpand);
      if ("sizeMultiplier" in o) opts.sizeMultiplier = Number(o.sizeMultiplier);

      if ("strict" in o) opts.strict = o.strict;
      if ("trust" in o) opts.trust = o.trust;
      if ("output" in o) opts.output = o.output;
      else opts.output = "html";
      const macros = o.macros;
      if (macros && typeof macros === "object" && !Array.isArray(macros)) {
        opts.macros = macros;
      }

      if (!("strict" in opts)) opts.strict = false;
      if (!("trust" in opts)) opts.trust = true;

      setStatus("pending", null, null);
      window.__ready = false;

      const targetImpl = typeof implPreference === "string" && implPreference.length > 0
        ? implPreference
        : defaultImpl;
      let resolvedImpl = defaultImpl;
      try {
        resolvedImpl = await loadImplementation(targetImpl);
      } catch (err) {
        const message = err && err.message ? err.message : String(err);
        const stack = err && err.stack ? String(err.stack) : null;
        setStatus("error", message, stack);
        window.__ready = true;
        return { state: "error", message, stack };
      }

      try {
        const texSource =
          typeof o.tex === "string" ? o.tex : o.tex == null ? "" : String(o.tex);
        window.katex.render(texSource, mathNode, opts);
      } catch (err) {
        const message = err && err.message ? err.message : String(err);
        const stack = err && err.stack ? String(err.stack) : null;
        setStatus("error", message, stack);
        window.__ready = true;
        return { state: "error", message, stack };
      }

      await waitForImagesIn(document);
      await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
      window.__currentImpl = resolvedImpl;
      window.__ready = true;
      return setStatus("rendered", null, null);
    }

    // Expose a programmatic API so the same page can render multiple cases without reload.
    window.runCase = function(payload) {
      return renderInternal(payload, defaultImpl);
    };

    window.renderWithImpl = function(mode, payload) {
      return renderInternal(payload, mode);
    };

    window.captureHtmlSnapshot = function() {
      const mathNode = document.getElementById("math");
      const preNode = document.getElementById("pre");
      const postNode = document.getElementById("post");
      const statusObj = typeof window.__status === "object" && window.__status !== null
        ? window.__status
        : null;
      const state = statusObj && statusObj.state ? String(statusObj.state) : null;
      const message = statusObj && statusObj.message ? String(statusObj.message) : null;
      const statusText = state && message ? `${state}: ${message}` : (state || message || null);
      return {
        impl: window.__currentImpl || defaultImpl || null,
        status: statusText,
        pre: preNode ? preNode.innerHTML : "",
        math: mathNode ? mathNode.innerHTML : "",
        post: postNode ? postNode.innerHTML : "",
      };
    };

    window.updateCompareStatus = function(state, message, stack) {
      return setStatus(state, message || null, stack || null);
    };

    async function main() {
      const { payload, error } = decodePayloadFromSearch(searchParams);
      if (error) {
        setStatus("error", error, null);
        window.__ready = true;
        return;
      }

      window.__initialPayload = payload;

      const result = await window.runCase(payload);
      if (result && result.state === "error") {
        return;
      }

      if (document.fonts && document.fonts.ready) {
        try { await document.fonts.ready; } catch (_) {}
      }
      await ensureFonts();
    }

    main();
  </script>
</body>
</html>
